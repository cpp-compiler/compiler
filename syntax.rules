number : 0|1|...|9
ident : [a-z|A-Z]
expr : number/ident +/- ... ;


# assignment:
ident = expr

# declare and assign
ident := expr

# if
if expr {
	expr 1
	expr 2
	...
	expr n
}

# else (requires previous if)
else expr {
	expr 1
	expr 2
	...
	expr n
}

// func definition
[optional]

IDENT HASTYPE [IDENT IDENT, ...] OBRACE
	stmt
	...
CBRACE

// example
ident :: int a {
	a + = 1;
}


// struct definition
:: = HASTYPE
struct = KEYSTRUCT

IDENT HASTYPE KEYSTRUCT OBRACE
	stmt
	...
CBRACE

// example:
Foo :: struct {
	int x;
	int y;

	addThem :: int -> int { // later on
 		return x + y;
	}
}

f := Foo{2, 3};
f.addThem();

Bar :: Foo { // way later on
	newFunc :: {
		print("kek");
	}
}

// alias
type :: anotherType;

// alias and add stuff (inheritance?)
type :: anotherType {
	int y; 
}
// read as: has the type anotherType


# more examples

f := Foo{}; // implicit constructor
add :: Foo f, i32 x, i32 y {}
f.add(2, 3); // first arg can be used as receiver
// or
add(f, 2, 3); // exactly the same
